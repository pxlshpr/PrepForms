import SwiftUI

struct AnimatableGoalValueModifier: AnimatableModifier {
    
    @Environment(\.colorScheme) var colorScheme
    @State var size: CGSize = .zero

    var value: Double
    var fontSize: CGFloat
    
    var animatableData: Double {
        get { value }
        set { value = newValue }
    }
    
    func body(content: Content) -> some View {
        content
            .frame(width: size.width, height: size.height)
            .overlay(
                animatedLabel
                    .readSize { size in
                        self.size = size
                    }
            )
    }
    
    var animatedLabel: some View {
        Text(value.formattedGoalValue)
            .font(.system(size: fontSize, weight: .bold, design: .rounded))
            .frame(maxWidth: .infinity)
            .multilineTextAlignment(.trailing)
            .fixedSize(horizontal: true, vertical: false)
    }
}

public extension View {
    func animatedGoalValueModifier(value: Double, fontSize: CGFloat) -> some View {
        modifier(AnimatableGoalValueModifier(value: value, fontSize: fontSize))
    }
}

struct AnimatableGoalEquivalentValueModifier: AnimatableModifier {
    
    @Environment(\.colorScheme) var colorScheme
    @State var size: CGSize = .zero

    var value: Double
    
    var animatableData: Double {
        get { value }
        set { value = newValue }
    }
    
    func body(content: Content) -> some View {
        content
            .frame(width: size.width, height: size.height)
            .overlay(
                animatedLabel
                    .readSize { size in
                        self.size = size
                    }
            )
    }
    
    var animatedLabel: some View {
        Text(value.formattedGoalValue)
            .font(.system(size: 18, weight: .semibold, design: .rounded))
            .foregroundColor(Color(.secondaryLabel))
            .frame(maxWidth: .infinity)
            .multilineTextAlignment(.trailing)
            .fixedSize(horizontal: true, vertical: false)
    }
}

public enum AnimatableGoalValueStyle {
    case cell
    case form
    
    var valueFont: Font {
        switch self {
        case .cell:
            return .system(size: 28, weight: .medium, design: .rounded)
        case .form:
            return .system(size: 18, weight: .semibold, design: .rounded)
        }
    }
    
    func valueColor(isAutoGenerated: Bool) -> Color {
        switch self {
        case .cell:
            return isAutoGenerated ? Color(.tertiaryLabel) : Color(.label)
        case .form:
            return .secondary
        }
    }
    
    var unitFont: Font {
        switch self {
        case .cell:
//            return .system(size: 17, weight: .semibold, design: .rounded)
            return .system(size: 17, weight: .bold, design: .rounded)
        case .form:
            return .system(size: 15, weight: .semibold, design: .rounded)
        }
    }
    
    func unitColor(isAutoGenerated: Bool) -> Color {
        switch self {
        case .cell:
            return isAutoGenerated ? Color(.tertiaryLabel) : Color(.secondaryLabel)
        case .form:
            return Color(.tertiaryLabel)
        }
    }
    
    var prefixFont: Font {
        switch self {
        case .cell:
            return .title3
        case .form:
            return .system(size: 18, weight: .semibold, design: .rounded)
        }
    }
    
    var prefixColor: Color {
        Color(.tertiaryLabel)
    }
}

public extension View {
    func animatedGoalEquivalentValueModifier(value: Double) -> some View {
        modifier(AnimatableGoalEquivalentValueModifier(value: value))
    }
}
